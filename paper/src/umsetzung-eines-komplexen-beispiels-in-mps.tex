Mittels dieses komplexen Beispieles sollen die Möglichkeiten von \ac{MPS} nun weiter ausgeschöpft werden.
Dazu soll eine \ac{DSL} entstehen, die nicht für Entwickler ausgelegt ist.

\subsection{Anforderungen}\label{subsec:anforderungen}
Die \ac{DSL}, beziehungsweise die beiden \acp{DSL}, sollen für Designer ausgelegt sein.
Das Ziel dieses Beispiels soll es sein, den Kommunikations--Overhead beim Erstellen von Themes zu eliminieren.
\begin{figure}[ht]
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[width=\textwidth]{../assets/img/diagrams/designflow_old.mmd}
        \end{center}
        \caption{Vorher}
        \label{subfig:ablauf-designanpassungen-alt}
    \end{subfigure}
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[width=\textwidth]{../assets/img/diagrams/designflow_new.mmd}
        \end{center}
        \caption{Nacher}
        \label{subfig:ablauf-designanpassungen-neu}
    \end{subfigure}
    \caption{Ablauf Designanpassungen}
    \label{fig:ablauf-designanpassungen}
\end{figure}

Dazu wird zunächst der aktuelle Ablauf aus dem Team--App des \ac{SWR} aus \autoref{subfig:ablauf-designanpassungen-alt} betrachtet.
Hier gibt es viele Indirektionen, die zum einen Zeitaufwändig sind, aber auch Fehler verursachen können.

Bedeutend effektiver wäre der Ablauf aus \autoref{subfig:ablauf-designanpassungen-neu}.
Hier bearbeitet ausschließlich die Autorität (Designer) über das Feature (Aussehen) auch dieses Feature.
Alle anderen Schritte sind automatisiert.

Der große Vorteil dabei ist, dass eine \ac{SSOT} sichergestellt wird.
Es handelt sich also um eine Optimierung der Informationsarchitektur.

Unter Beachtung der zur Verfügung stehenden Zeit musste allerdings auf ein paar Aspekte verzichtet werden.
Zunächst wird kein Figma Projekt generiert werden.
Dies wäre zunächst zu komplex, da eine Generation von Figmas\footnote{Figma ist ein Tool zum Erstellen von Designs und Prototypen~\autocite{figma-inc-no-date}} eigenem Dateiformat erstellt werden müsste.
Des Weiteren wird als Zielsprache zunächst ausschließlich Java implementiert.
Um die Sprachen im Team--App effektiv einsetzen zu können, müsste eine Generation zu Dart und optimalerweise parallel zu Kotlin sowie Swift stattfinden.
Hierzu wäre es allerdings zunächst nötig, diese Sprachen mit einem TextGen Aspekt abzubilden.
Da die BaseLanguage Java bereits abbildet, zeigt die Umsetzung in Java, was zukünftig möglich ist.

\paragraph*{}
Die erste der beiden Sprachen soll es ermöglichen, Design--Systeme zu erstellen.
Diese werden dann in Java als ein Datenmodell abgelegt.
In dieser Sprache könnten die Entwickler ein Framework für die Designer festlegen.
Des Weiteren soll in Zukunft zum Beispiel das Material--Theme von Flutter~\autocite{google-ireland-limited-no-date} bereits als Runtime--Environment bestehen, sodass Systeme bestehender Frameworks genutzt werden können.

\paragraph*{}
Die zweite der beiden Sprachen soll es nun erlauben, diese Design--Systeme mit Werten zu befüllen.
So können dann Themes für verschiedene Apps oder Libraries erstellt werden.

\subsubsection{Design--System --- Material}
Das Design--System beschreibt lediglich ein Datenmodell.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Design--System}--Konzepts anhand von Material},label={lst:sprachdesign-designsystem}]{../assets/code/design_system/creator/example/material/Material.designsystem}
Jedes {\ttfamily Design--System} erbt dabei in Java von derselben Klasse.
Wichtig ist, dass jedes {\ttfamily Design--System} dadurch seinen eigenen Typen spezifiziert.

{\ttfamily subsystems} sind dabei lediglich andere {\ttfamily Design--System} und könnten auch in einer separaten Datei definiert werden.
Allerdings werden sie so in Java im Scope der Klasse angelegt.

{\ttfamily properties} hingegen sind die Werte des Datenmodells.
\lstinputlisting[language=DesignSystemEnum,caption={Sprachdesign des {\ttfamily Enum}--Konzepts anhand von Brightness},label={lst:sprachdesign-enum}]{../assets/code/design_system/creator/example/material/brightness.enum}
Sie haben einen Typen, also ein anderes {\ttfamily Design--System}, einen {\ttfamily Enum} oder einen \enquote{primitiven} Typen.
Letztere sind direkt in der Sprache als Konzept definiert.
Es sind die grundlegenden Designelemente, wie Farben, Abstände oder Strings.

Des Weiteren können {\ttfamily properties} über das {\ttfamily by}--Schlüsselwort parametrisiert werden.
Dies ist hilfreich, wenn Dinge an Zustände geknüpft sind.
Ein einfaches Beispiel sind Buttons.

\subsubsection{App--Theme --- CounterAppTheme}
Das App--Theme konsumiert nun ein (oder mehrere) Design--Systeme.

Im Regelfall verwenden Designer in Themes nicht direkt statische Werte.
Analog zu Figma~\autocite{figma-inc-no-date} implementiert die App--Theme--Sprache sogenannte primitive Tokens.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens}--Konzepts anhand von hellen Farben},label={lst:sprachdesign-light-color-tokens}]{../assets/code/design_system/app/example/counter/LightColorTokens.primitivetokens}
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens}--Konzepts anhand von dunklen Farben},label={lst:sprachdesign-dark-color-tokenn}]{../assets/code/design_system/app/example/counter/DarkColorTokens.primitivetokens}
Diese sind konstante Werte, welche anschließend in Themes ihrer Funktion zugeordnet werden.
Dies stellt sicher, dass es eine \ac{SSOT} gibt und Werte in der App einheitlich sind.

In dieser Sprache können Themes in Abhängigkeit von Parametern definiert werden.
Das klassischste Beispiel hierfür wäre ein Light-- und ein Dark--Theme in Abhängigkeit zu der in \autoref{lst:sprachdesign-enum} spezifizierten Aufzählung.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily abstract Primitive Tokens}--Konzepts anhand von Farben},label={lst:sprachdesign-color-tokens}]{../assets/code/design_system/app/example/counter/ColorTokens.primitivetokens}
In Anbetracht darauf können bereits die primitiven Tokens eine Vererbungshierarchie erzeugen.
Dabei werden in der abstrakten Klasse alle Tokens deklariert, aber nur die Themeunabhängigen definiert.
Die konkreten Klassen definieren anschließend die fehlenden Werte.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens Resolver}--Konzepts anhand von Farben},label={lst:sprachdesign-all-color-tokens}]{../assets/code/design_system/app/example/counter/AllColorTokens.primitivetokens}
Anschließend kann spezifiziert werden, wann welche Implementierung verwendet wird.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens}--Konzepts anhand von Textstyles},label={lst:sprachdesign-font-tokens}]{../assets/code/design_system/app/example/counter/FontTokens.primitivetokens}
Die primitiven Tokens sind gruppiert nach ihren Typen.
Die Typen können erneut primitiver Natur sein oder auf einer Referenz basieren.

Zuletzt werden die primitiven Tokens in App--Themes verwendet.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily App--Theme}--Konzepts anhand des Themes einer Counter--App},label={lst:sprachdesign-counter-theme}]{../assets/code/design_system/app/example/counter/CounterTheme.theme}
Zunächst werden die verwendeten primitiven Tokens spezifiziert.
Anschließend werden konstante Werte sowie Werte der primitiven Tokens den Feldern im Design--System zugeordnet.
Dabei lassen sich beliebige Kontrollflussanweisungen einbauen.
Die Kontrollflussanweisungen beziehen sich dabei immer auf die Parameter des Themes.

\subsection{Umsetzung}\label{subsec:umsetzung}
\begin{figure}
    \includegraphics[width=\textwidth]{../assets/img/diagrams/logic_structure.mmd}
    \caption{Struktur des Kontrollflusses der Design--System--Sprachen}
    \label{fig:designsystem-logic-structure}
\end{figure}
In der Praxis wurden drei Sprachen für die Umsetzung des Projekts verwendet.
Die gemeinsamen Kontrollflussanweisungen und das Typsystem wurden ausgelagert.
Dies war notwendig, da die Mapping--Labels nicht über mehrere Generatoren hinweg verwendet werden können.
Die Referenzen, im Klassendiagramm aus \autoref{fig:designsystem-logic-structure} als Aggregationen zu erkennen, konnten also anders nicht in Java übersetzt werden.
Damit dieses Label gesetzt werden konnte, waren an den entsprechenden Stellen Wrapper--Konzepte notwendig, welche im Diagramm nicht abgebildet sind.

Für die erste Umsetzung dieses Projektes waren nicht alle Aspekte von \ac{MPS} erforderlich.
Neben der Struktur wurden noch Editor, Actions, Constraints, Behaviour, Typesystem und Intentions verwendet.

Das Vorgehen war dabei in der Regel einheitlich:
\begin{enumerate}
    \item Basierend auf der Planung aus \autoref{subsec:anforderungen} wird ein Strukturknoten erstellt, gegebenenfalls auch ein abstrakter Knoten und mehrere Kinder.
    \item Anschließend wird der Editor erstellt, um einen Vergleich in der Darstellung zu bekommen.
    Außerdem kann sich der Entwickler die Sprache so leichter visualisieren.
    \item Typesystem Regeln und Actions definieren, da diese in den folgenden Schritten besonders hilfreich sind.
    \item Definieren von Scopes, um im Generator keine falschen Werte zu erhalten.
    \item Erstellen des Generators.
    Es ist wichtig, dass das Backend des Compilers steht, damit bewiesen ist, dass die Sprache technisch funktional ist.
    \item Transformatoren erstellen, um das Bearbeiten auch Laien zu ermöglichen.
    \item Constraints erstellen, um invalide Eingaben zu verhindern.
    \item Intentions und weitere Nice--To--Have--Features einbauen.
\end{enumerate}

Aus Zeitgründen konnten in diesem Prototypen nur die ersten fünf Phasen für Design--System, PrimitiveTokens und PrimitiveTokensResolver umgesetzt werden.
Zur Veranschaulichung für die Designer aus \autoref{subsec:befragungen} wurden die weiteren Phasen anhand einzelner Konzepte demonstriert.
Mehr dazu in \autoref{subsec:befragungen}

Im Folgenden soll dieses Vorgehen anhand der Logik beispielhaft erläutert werden.
Die Struktur ist in \autoref{fig:designsystem-logic-structure} dargestellt.

Begonnen wurde mit den Types.
Alle primitiven Typen sind lediglich Platzhalter.
Der {\ttfamily DSReferenceType} hingegen hat zur Aufspaltung in drei Sprachen geführt.
Die Knoten ließen sich hier recht schnell anlegen und auch die Editoren waren trivial.
Allerdings bilden sie noch nicht alleine auf eine Java--Klasse ab.
Deshalb wurde hier zunächst das Design--System--Konzept in seiner eigenen Sprache umgesetzt, um die Typen testen zu können.

Der restliche Kontrollfluss kann nur im PrimitiveTokensResolver getestet werden.
Entsprechend wurde darauf hingearbeitet.
Dazu muss als Erstes das Konzept der {\ttfamily DSStatementList} existieren, da diese hier verwendet wird.
Anschließend kann der Resolver mit seinem Editor spezifiziert werden.

Um die Statements nun mit Inhalt zu füllen, wurde ein Top--Down--Ansatz gewählt.
Es wurden also zunächst die Statements erstellt, und anschließend die Expressions.
Dabei wurde sich zunächst auf die Literale fokussiert, da diese am einfachsten zu implementieren sind.
Von jedem abstrakten Konzept muss zunächst mindestens eine Implementierung vorhanden sein, bevor mit der Implementierung des zugehörigen Generators begonnen werden kann.

Bei den Literalen wurde zunächst das Typsystem implementiert.
Dies ist auch im Diagramm durch gestrichelte Linien zu erkennen.
Alle anderen Expressions wurden nicht statisch, sondern über ihren Inhalt typisiert.
So kann sich an allen anderen Stellen auf die Typsicherheit verlassen werden.

Als der Generator funktioniert hat, wurden jetzt alle fehlenden, konkreten Konzepte sowie die Variablen und Methoden nachgezogen.

So lässt sich die Umsetzung einer komplexen (Teil--)Sprache leicht in autonome Subsysteme zerlegen.

Dabei sind bestimmte Phasen der Umsetzung leichter gefallen als andere.
Das Erstellen der Konzepte fiel dabei für die einfachen Anwendungsfälle bereits von Beginn an leicht.
Für die komplexeren Anwendungsfälle hat es nach einer kurzen eingewöhnungsphase auch intuitiv angefühlt.

Auch das Umsetzen der Editoren fällt mit der zugehörigen Sprache leicht, sobald die Ausrichtungscharaktere bekannt sind.

Das Typesystem hingegen ist eine Herausforderung für sich.
Die Typen selbst zu definieren ist nicht schwer, allerdings Vererbungshierarchien und andere Konzepte der Typsicherheit.
Hier ist die Menge an möglichen Regeln eine Herausforderung.

Auch Scopes sind nicht immer einfach.
Hier gibt es auch viele verschiedene Arten, um Scopes zu definieren.
Außerdem ist das Bubbling von {\ttfamily ScopeProvider}n nicht immer sofort ersichtlich, wenn der \ac{AST} komplexer ist.
Insgesamt sind Scopes mit einem mittleren Aufwand umsetzbar.

Der Generator hingegen ist ein größerer Aufwand.
% TODO: Weiterschreiben

\subsection{Herausforderungen und Probleme}\label{subsec:herausforderungen-und-probleme}
Nichtsdestotrotz gab und gibt es viele Schwierigkeiten bei der Umsetzung.
Besonders bei der Umsetzung der Generatoren kam es immer wieder zu Problemen.

Zunächst war das Aufspalten von zwei in drei Packages sehr aufwändig, da es sich nicht um Textdateien handelt.
Copy--Paste war also nur begrenzt einsetzbar, was dazu geführt hat, dass effektiv alles, was in~\autoref{fig:designsystem-logic-structure} abgebildet ist, manuell abgetippt werden musste.

Außerdem ist es im Allgemeinen sehr unangenehm, dass Workarounds genutzt werden müssen, um die Mapping--Labels über mehrere Sprachen hinweg zu erhalten.

Ein weiteres Problem sind die Referenzierungen von anderen Solutions und deren Verarbeitung im Generator.
Im Rahmen dieses Prototypes konnte dies nicht funktional gemacht werden, auch wenn bei dem Versuch viel Zeit verloren gegangen ist.
Sobald aus einer Solution ein Konzept einer anderen Solution als Referenz verwendet wird, kann die entsprechende Referenz in Java nicht aufgelöst werden.
Dies ist eine erhebliche einschränkung der strukturierten Zusammenarbeit von Entwicklern und Designern, da der Zugriff auf verschiedene Dateien nicht effektiv verwaltet werden kann.

Zusammenfassend lässt sich sagen, dass an vielen verschiedenen Stellen immer wieder die hohe komplexität von \ac{MPS} eine große Herausforderung für die Entwicklung ist.
