Mittels dieses komplexen Beispieles sollen die Möglichkeiten von \ac{MPS} nun weiter ausgeschöpft werden.
Dazu soll eine \ac{DSL} entstehen, die nicht für Entwickler ausgelegt ist.

\subsection{Anforderungen}\label{subsec:anforderungen}
Die \ac{DSL}, beziehungsweise die beiden \acp{DSL}, sollen für Designer ausgelegt sein.
\begin{figure}[ht]
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[width=\textwidth]{../assets/img/diagrams/designflow_old.mmd}
        \end{center}
        \caption{Vorher}
        \label{subfig:ablauf-designanpassungen-alt}
    \end{subfigure}
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[width=\textwidth]{../assets/img/diagrams/designflow_new.mmd}
        \end{center}
        \caption{Nacher}
        \label{subfig:ablauf-designanpassungen-neu}
    \end{subfigure}
    \caption{Ablauf Designanpassungen}
    \label{fig:ablauf-designanpassungen}
\end{figure}
Das Ziel dieses Beispiels soll es sein, den Kommunikations--Overhead beim Erstellen von Themes zu eliminieren.

Dazu wird zunächst der aktuelle Ablauf aus dem Team App des \ac{SWR} aus \autoref{subfig:ablauf-designanpassungen-alt} betrachtet.
Hier gibt es viele Indirektionen, die zum einen Zeitaufwändig sind, aber auch Fehler verursachen können.

Bedeutend effektiver wäre der Ablauf aus \autoref{subfig:ablauf-designanpassungen-neu}.
Hier bearbeitet ausschließlich die Autorität (Designer) über das Feature (Aussehen) auch dieses Feature.
Alle anderen Schritte sind automatisiert.

Der große Vorteil dabei ist, dass eine \ac{SSOT} sichergestellt wird.
Es handelt sich also um eine Optimierung der Informationsarchitektur.

Unter Beachtung der zur Verfügung stehenden Zeit musste allerdings auf ein paar Aspekte verzichtet werden.
Zunächst wird kein Figma Projekt generiert werden.
Dies wäre zunächst zu komplex, da eine Generation von Figmas\footnote{Figma ist ein Tool zum Erstellen von Designs und Prototypen~\autocite{figma-inc-no-date}} eigenem Dateiformat erstellt werden müsste.
Des Weiteren wird als Zielsprache zunächst ausschließlich Java implementiert.
Um die Sprachen im Team App effektiv einsetzen zu können, müsste eine Generation zu Dart und optimalerweise parallel zu Kotlin sowie Swift stattfinden.
Hierzu wäre es allerdings zunächst nötig, diese Sprachen mit einem TextGen Aspekt abzubilden.
Da die BaseLanguage Java bereits abbildet, zeigt die Umsetzung in Java, was zukünftig möglich ist.

\paragraph*{}
Die erste der beiden Sprachen soll es ermöglichen, Designsysteme zu erstellen.
Diese werden dann in Java als ein Datenmodell abgelegt.
In dieser Sprache könnten die Entwickler ein Framework für die Designer festlegen.
Des Weiteren soll in Zukunft zum Beispiel das Material Theme von Flutter~\autocite{google-ireland-limited-no-date} bereits als Runtime Environment bestehen, sodass Systeme bestehender Frameworks genutzt werden können.

\paragraph*{}
Die zweite der beiden Sprachen soll es nun erlauben, diese Designsysteme mit Werten zu befüllen.
So können dann Themes für verschiedene Apps oder Libraries erstellt werden.

\subsubsection{Designsystem --- Material}
Das Designsystem beschreibt lediglich ein Datenmodell.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily DesignSystem} Konzepts anhand von Material},label={lst:sprachdesign-designsystem}]{../assets/code/design_system/creator/example/material/Material.designsystem}
Jedes {\ttfamily DesignSystem} erbt dabei in Java von derselben Klasse.
Wichtig ist, dass jedes {\ttfamily DesignSystem} dadurch seinen eigenen Typen spezifiziert.

\text{\ttfamily subsystems} sind dabei lediglich andere {\ttfamily DesignSystem} und könnten auch in einer separaten Datei definiert werden.
Allerdings werden sie so in Java im Scope der Klasse angelegt.

\text{\ttfamily properties} hingegen sind die Werte des Datenmodells.
\lstinputlisting[language=DesignSystemEnum,caption={Sprachdesign des {\ttfamily enum} Konzepts anhand von Brightness},label={lst:sprachdesign-enum}]{../assets/code/design_system/creator/example/material/brightness.enum}
Sie haben einen Typen, also ein anderes {\ttfamily DesignSystem}, einen {\ttfamily enum} oder einen \enquote{primitiven} Typen.
Letztere sind direkt in der Sprache als Konzept definiert.
Es sind die grundlegenden Designelemente, wie Farben, Abstände oder Strings.

Des Weiteren können {\ttfamily properties} über das {\ttfamily by} Schlüsselwort parametrisiert werden.
Dies ist hilfreich, wenn Dinge an Zustände geknüpft sind.
Ein einfaches Beispiel sind Buttons.

\subsubsection{App--Theme --- CounterAppTheme}
Das App--Theme konsumiert nun ein (oder mehrere) Designsysteme.

Im Regelfall verwenden Designer in Themes nicht direkt statische Werte.
Analog zu Figma~\autocite{figma-inc-no-date} implementiert die App Theme Sprache sogenannte primitive Tokens.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens} Konzepts anhand von hellen Farben},label={lst:sprachdesign-light-color-tokens}]{../assets/code/design_system/app/example/counter/LightColorTokens.primitivetokens}
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens} Konzepts anhand von dunklen Farben},label={lst:sprachdesign-dark-color-tokenn}]{../assets/code/design_system/app/example/counter/DarkColorTokens.primitivetokens}
Diese sind konstante Werte, welche anschließend in Themes ihrer Funktion zugeordnet werden.
Dies stellt sicher, dass es eine \ac{SSOT} gibt und Werte in der App einheitlich sind.

In dieser Sprache können Themes in Abhängigkeit von Parametern definiert werden.
Das klassischste Beispiel hierzu wäre ein Light-- und ein Dark--Theme in Abhängigkeit zu der in \autoref{lst:sprachdesign-enum} spezifizierten Aufzählung.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily abstract Primitive Tokens} Konzepts anhand von Farben},label={lst:sprachdesign-color-tokens}]{../assets/code/design_system/app/example/counter/ColorTokens.primitivetokens}
In Anbetracht darauf können bereits die primitiven Tokens eine Vererbungshierarchie erzeugen.
Dabei werden in der abstrakten Klasse alle Tokens deklariert, aber nur die Themeunabhängigen definiert.
Die konkreten Klassen definieren anschließend die fehlenden Werte.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens Resolver} Konzepts anhand von Farben},label={lst:sprachdesign-all-color-tokens}]{../assets/code/design_system/app/example/counter/AllColorTokens.primitivetokens}
Anschließend kann spezifiziert werden, wann welche Implementierung verwendet wird.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily Primitive Tokens} Konzepts anhand von Textstyles},label={lst:sprachdesign-font-tokens}]{../assets/code/design_system/app/example/counter/FontTokens.primitivetokens}
Die primitiven Tokens sind gruppiert nach ihren Typen.
Die Typen können erneut primitiver Natur sein, oder auf einer Referenz basieren.

Zuletzt werden die primitiven Tokens in Apps verwendet.
\lstinputlisting[language=DesignSystem,caption={Sprachdesign des {\ttfamily App} Konzepts anhand des Themes einer Conter App},label={lst:sprachdesign-counter-theme}]{../assets/code/design_system/app/example/counter/CounterTheme.theme}
Zunächst werden die verwendeten primitiven Tokens spezifiziert.
Anschließend werden konstante Werte sowie Werte der primitiven Tokens den Feldern im Designsystem zugeordnet.
Dabei lassen sich beliebige Kontrollflussanweisungen einbauen.
Die Kontrollflussanweisungen beziehen sich dabei immer auf die Parameter des Themes.

\subsection{Umsetzung}\label{subsec:umsetzung}
Beide Sprachen benötigen nicht alle Aspekte von \ac{MPS}.
Neben der Struktur werden noch Editor, Actions, Constraints, Behaviour, Typesystem und Intentions verwendet.

\subsection{Herausforderungen und Probleme}\label{subsec:herausforderungen-und-probleme}
\lipsum[5]
