In diesem Kapitel werden die grundsätzlichen Definitionen und eine historische einordnung sowie ein Überblich über die aktuellen Möglichkeiten von \ac{DSL} geschaffen.

\subsection{\aclp{DSL}}\label{subsec:domain-specific-languages}
Die erste Frage, die es zu klären gibt, ist: Was sind eigentlich \ac{DSL}?
\begin{displayquote}[\cite{jetbrains-sro-no-dateC}]
    A \ac{DSL} is a programming language with a higher level of abstraction optimized for a specific class of problems.
    A \ac{DSL} uses the concepts and rules from the field or domain.
\end{displayquote}
Laut JetBrains definieren sich \acp{DSL} also über ihr Sprachdesign, welches Konzepte einer spezifischen, fachlichen Domäne beinhaltet.
Wikipedia definiert es etwas anders:
\begin{displayquote}[\cite{wikipedia-contributors-2024C}]
    A \ac{DSL} is a computer language specialized to a particular application domain.
    This is in contrast to a \ac{GPL}, which is broadly applicable across domains.
\end{displayquote}
Hier werden \acp{DSL} als gegenteil von \acp{GPL} genannt, welche zusammen die Programmiersprachen ausmachen.
Diese sind im Wörterbuch definiert als:
\begin{displayquote}[\cite{unknown-author-no-date}]
    Code of reserved words and symbols used in computer programs, which give instructions to the computer on how to accomplish certain computing tasks.
\end{displayquote}
Also eine Kodierung, welche Anweisungen an einen Computer gibt.

Zusammenfassend lässt sich sagen, dass \acp{DSL} Kodierungen sind, die fachspezifisch von einer Menge von Schlüsselwörtern und strukturierten, dynamischen Inhalt auf eine von (mindestens) einem Computer--(Programm) verstandene Eingabe--(Datei) abbildet.
Dabei stehen fachspezifische Paradigmen vor den klassischen Programmierparadigmen~\autocite{wikipedia-contributors-2024D} im Zentrum des Sprachdesigns.

Das wohl bekannteste Beispiel ist \ac{SQL}.~\autocite{unknown-author-2023}
\ac{SQL} ist eine durch die \ac{ISO} genormte \ac{DSL}; spezifischer eine sogenannte \textit{query language}.
Auf Deutsch Abfragesprachen genannt, dienen diese \acp{DSL}, der interaktionen mit \acp{DBMS}.
Die Domäne ist in diesem Fall also die Datenhaltung \textit{strukturierter} Daten.

Da es etliche \acp{DBMS} gibt, welche dem \ac{SQL}--Standard folgen, gibt es für \ac{SQL} auch etliche Compiler beziehungsweise Interpreter.
Diese Compiler sind dabei stark mit dem jeweiligen \ac{DBMS} verwoben.
Es gibt also keine einheitliche Codebasis.
Dies wäre mit bekannten Tools des Compilerbaus, namentlich \textbf{Lex} \& \textbf{YACC}.
Diese werden im folgenden Kapitel behandelt.

\begin{figure}[ht]
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[height=2.5cm]{../assets/img/diagrams/compiler.mmd}
        \end{center}
        \caption{Compiler}
        \label{subfig:compiler-and-interpreter-compiler}
    \end{subfigure}
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[height=2.5cm]{../assets/img/diagrams/interpreter.mmd}
        \end{center}
        \caption{Interpreter}
        \label{subfig:compiler-and-interpreter-interpreter}
    \end{subfigure}
    \caption{Compiler \& Interpreter~\autocite{aho-2006}}
    \label{fig:compiler-and-interpreter}
\end{figure}
\newpage

\subsection{Compilerbau}\label{subsec:compilerbau}
\begin{wrapfigure}{rH}{0.47\textwidth}
    \begin{center}
        \includegraphics[width=0.45\textwidth]{../assets/img/diagrams/compiler_phases.mmd}
    \end{center}
    \caption{Phasen der Compiler--Pipeline~\autocite{aho-2006}}
    \label{fig:compiler-phases}
\end{wrapfigure}
Was von Entwicklern umgangssprachlich \qq{Compiler} genannt wird, bezeichnet eigentlich die Compiler--Pipeline.
Der eigentliche Compiler, oder auch Code Generator, (Siehe \autoref{fig:compiler-phases}) ist ein Tool, welches aus einer abstrakten Representation die Zielsprache, im folgenden Programm genannt, generiert.

Ein Programm ist dabei definiert als eine Black--Box, welche eine Eingabe in eine Ausgabe transformiert.
Damit kann zwischen zwei verschiedenen Aufbauten unterscheiden: Compiler erstellen aus Code ein Programm, welches eine Eingabe in eine Ausgabe transformiert (Siehe \autoref{subfig:compiler-and-interpreter-compiler}) und Interpreter transformieren unter der Verwendung von Code eine Eingabe in eine Ausgabe.~(Siehe \autoref{subfig:compiler-and-interpreter-interpreter})

Effektiv benötigen beide Klassen von Tools die selben Phasen.
Es muss auf irgend einem Weg, durch das konsekutive ausführen von Transformationen aus dem Code das Programm werden.

Diese Phasen sind klassischer Weise jene aus \autoref{fig:compiler-phases}.
Diese Phasen wurden auch im \ac{POSIX}, einem Standard für Betriebssysteme, festgehalten.~\autocite{ieee-sa-1993}

\paragraph{Lexical Analyzer,} oder auch \textbf{Tokenizer}, gruppieren dabei den Code in \textbf{Tokens}.
Ein Token ist dabei ein Zweitupel aus seinem Typen und seinem Wert, ein optionalen Eintrag in der SymbolTable.

Die zugrundeliegende Datenstruktur bleibt dabei ein Stream.
Es handelt sich also immer noch um eine lineare Datenstruktur.

Der wohl bekannteste Tokenizer ist dabei Lex.~\autocite{wikipedia-contributors-2024G}
Lex folgt dem \ac{POSIX} Standard und ist in \autoref{subsubsec:lex} beschriebene.

\paragraph{Syntax Analyzer,} oder auch \textbf{Parser}, analysieren die Reihenfolge, in der die einzelnen Tokens evaluiert werden.
Dazu wird mittels einer \ac{CFG}~\autocite{wikipedia-contributors-2024H} ein \textbf{syntax tree}, oder auch \textbf{\ac{AST}}, erstellt.

\lipsum[5]

\paragraph{Semantic Analyzer} analysiert die Nodes des \ac{AST} auf semantische korrektheit.

\lipsum[5]

\paragraph{Intermediate Code Generator} erstellt Text aus dem \ac{AST} eine Computer--verständliche Zwischendarstellung.

Ein Beispiel aus~\cite{aho-2006} wäre der three--address code.
Dieser ist eine klassische \textbf{intermediate representation} beim Kompilieren zu Assembly.

Der Zweck dieser Zwischendarstellung ist meistens, dass sie in einer Textdatei abgelegt werden kann.
Der Vorteil davon ist, dass das Frontend der Compiler--Pipeline\footnote{Als Frontend des Compilers werden die ersten 5 Phasen bezeichnet, als Backend die letzten beiden.} klassischerweise unabhängig von der Prozessorarchitektur ist und es so potenziell mehrere, unabhängig voneinander entwickelte, Backends für die verschiedenen Prozessorarchitekturen geben kann.

Da \acp{DSL} im Gegensatz zu \acp{GPL} meist keine Abhängigkeit zu Prozessorarchitekturen haben, fällt die Wahl der intermediate representation häufig direkt auf den \ac{AST}.

\paragraph{Machine--Independent Code Optimizer} tun genau das, was der Name auch sagt: sie nehmen mögliche Optimierungen an der intermediate representation vor.

Diese Optimierungen beinhalten zum Beispiel das entfernen von unnötigem Code, Obfuscating von Identifiers, Aufräumen von Ressourcen, \dots.

Der Code kann anhand von verschiedensten Metriken optimiert werden.
Dazu zählt Geschwindigkeit, Dateigröße\footnote{Ist im Web wichtig.}, \dots.

Optimierungsphasen sind immer optional.
Im C Compiler kann zum Beispiel auch eingestellt werden, wie stark der Code optimiert werden soll.

\paragraph{Code Generator,} oder auch \textbf{Compiler}, \lipsum[5]

\paragraph{Machine--Dependent Code Optimizer} optimieren den Code analog zu Machine--Independent Code Optimizer, nur spezifisch für die Zielplattform.

\subsubsection{Lex}\label{subsubsec:lex}
\lipsum[5]

\subsubsection{\acs{YACC}}
\lipsum[5]

\subsubsection{Compiler}
Auch zum erstellen von Compilern gibt es Tools, allerdings ist es hier auch üblich, diese manuel zu erstellen.
In \autoref{lst:compiler} ist beispielhaft ein solcher Compiler für den in \autoref{sec:vergleich-der-tool-sets-anhand-eines-einfachen-beispiels} verwendeten Compiler der PlayerConfig--Sprache abgebildet.
\lstinputlisting[label={lst:compiler},caption={Einfacher Compiler in C},language=c]{../assets/code/c/compiler.c}
\lipsum[5]

\subsection{\acl{MPS}}\label{subsec:meta-programming-system}
\ac{MPS} macht einiges anders als \ac{POSIX}.
Der Ausgangspunkt\footnote{Eingabe des Programms} ist keine Textdatei, sondern der \ac{AST} der zu definierenden Sprache.
Dies funktioniert, da \ac{MPS} nur in der gleichnamigen \ac{IDE} verwendet werden kann.

\begin{wrapfigure}{lH}{0.5\textwidth}
    \begin{center}
        \includegraphics[width=0.48\textwidth]{../assets/img/diagrams/mps.mmd}
    \end{center}
    \caption{Grundlegende Struktur von \acs{MPS}}
    \label{fig:mps}
\end{wrapfigure}
Der \ac{AST} wird dabei durch den \textbf{Editor} in eine Representation für den Menschen gerendert und über Transformationsregeln bearbeitet.

Auch das Kompilieren läuft in der Regel anders.
Einfache Sprachen haben klassischen Code Generator, in \ac{MPS} \textbf{TextGen} genannt.
Im Regelfall werden allerdings Transpiler\footnote{Ein Compiler, der eine Sprache als Eingabe und eine andere Sprache als Ausgabe hat.} verwendet.
Diese übersetzen mittels einer Template--Sprache von einem \ac{MPS} \ac{AST} in einen anderen \ac{MPS} \ac{AST}.
So wird durch die Konkatenation

\lipsum[5]

\subsubsection{Structure}
\begin{figure}
    \includegraphics[width=\textwidth]{../assets/img/diagrams/ard_player_mps_structure.mmd}
    \caption{ARD.Player MPS Sprache Struktur}
    \label{fig:ard-player-mps-structure}
\end{figure}
\lipsum[5]

\subsubsection{TextGen}
\lipsum[5]

\subsubsection{Generator}
\lipsum[5]

\subsubsection{GenPlan}
\lipsum[5]

\subsubsection{Editor}
\lipsum[5]
