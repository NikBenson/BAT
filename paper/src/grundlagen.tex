In diesem Kapitel werden die grundsätzlichen Definitionen und eine historische einordnung sowie ein Überblich über die aktuellen Möglichkeiten von \ac{DSL} geschaffen.

\subsection{\aclp{DSL}}\label{subsec:domain-specific-languages}
Die erste Frage, die es zu klären gibt, ist: Was sind eigentlich \ac{DSL}?
\begin{displayquote}[\cite{jetbrains-sro-no-dateC}]
    A \ac{DSL} is a programming language with a higher level of abstraction optimized for a specific class of problems.
    A \ac{DSL} uses the concepts and rules from the field or domain.
\end{displayquote}
Laut JetBrains definieren sich \acp{DSL} also über ihr Sprachdesign, welches Konzepte einer spezifischen, fachlichen Domäne beinhaltet.
Wikipedia definiert es etwas anders:
\begin{displayquote}[\cite{wikipedia-contributors-2024C}]
    A \ac{DSL} is a computer language specialized to a particular application domain.
    This is in contrast to a \ac{GPL}, which is broadly applicable across domains.
\end{displayquote}
Hier werden \acp{DSL} als gegenteil von \acp{GPL} genannt, welche zusammen die Programmiersprachen ausmachen.
Diese sind im Wörterbuch definiert als:
\begin{displayquote}[\cite{unknown-author-no-date}]
    Code of reserved words and symbols used in computer programs, which give instructions to the computer on how to accomplish certain computing tasks.
\end{displayquote}
Also eine Kodierung, welche Anweisungen an einen Computer gibt.

Zusammenfassend lässt sich sagen, dass \acp{DSL} Kodierungen sind, die fachspezifisch von einer Menge von Schlüsselwörtern und strukturierten, dynamischen Inhalt auf eine von (mindestens) einem Computer--(Programm) verstandene Eingabe--(Datei) abbildet.
Dabei stehen fachspezifische Paradigmen vor den klassischen Programmierparadigmen~\autocite{wikipedia-contributors-2024D} im Zentrum des Sprachdesigns.

Das wohl bekannteste Beispiel ist \ac{SQL}.~\autocite{unknown-author-2023}
\ac{SQL} ist eine durch die \ac{ISO} genormte \ac{DSL}; spezifischer eine sogenannte \textit{query language}.
Auf Deutsch Abfragesprachen genannt, dienen diese \acp{DSL}, der interaktionen mit \acp{DBMS}.
Die Domäne ist in diesem Fall also die Datenhaltung \textit{strukturierter} Daten.

Da es etliche \acp{DBMS} gibt, welche dem \ac{SQL}--Standard folgen, gibt es für \ac{SQL} auch etliche Compiler--Pipelines beziehungsweise Interpreter.
Diese Compiler--Pipelines sind dabei stark mit dem jeweiligen \ac{DBMS} verwoben.
Es gibt also keine einheitliche Codebasis.
Dies wäre mit bekannten Tools des Compilerbaus, namentlich \textbf{Lex} \& \textbf{YACC}.
Diese werden im folgenden Kapitel behandelt.

\begin{figure}[ht]
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[height=2.5cm]{../assets/img/diagrams/compiler.mmd}
        \end{center}
        \caption{Compiler}
        \label{subfig:compiler-and-interpreter-compiler}
    \end{subfigure}
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[height=2.5cm]{../assets/img/diagrams/interpreter.mmd}
        \end{center}
        \caption{Interpreter}
        \label{subfig:compiler-and-interpreter-interpreter}
    \end{subfigure}
    \caption{Compiler \& Interpreter~\autocite{aho-2006}}
    \label{fig:compiler-and-interpreter}
\end{figure}
\newpage

\subsection{Compilerbau}\label{subsec:compilerbau}
\begin{wrapfigure}{rH}{0.47\textwidth}
    \begin{center}
        \includegraphics[width=0.45\textwidth]{../assets/img/diagrams/compiler_phases.mmd}
    \end{center}
    \caption{Phasen der Compiler--Pipeline~\autocite{aho-2006}}
    \label{fig:compiler-phases}
\end{wrapfigure}
Was von Entwicklern umgangssprachlich \qq{Compiler} genannt wird, bezeichnet eigentlich die Compiler--Pipeline.
Der eigentliche Compiler, oder auch Code Generator, (Siehe \autoref{fig:compiler-phases}) ist ein Tool, welches aus einer abstrakten Representation die Zielsprache, im folgenden Programm genannt, generiert.

Ein Programm ist dabei definiert als eine \qq{Black--Box}, welche eine Eingabe in eine Ausgabe transformiert.
Damit kann zwischen zwei verschiedenen Aufbauten unterscheiden: Compiler erstellen aus Code ein Programm, welches eine Eingabe in eine Ausgabe transformiert (Siehe \autoref{subfig:compiler-and-interpreter-compiler}) und Interpreter transformieren unter der Verwendung von Code eine Eingabe in eine Ausgabe.~(Siehe \autoref{subfig:compiler-and-interpreter-interpreter})

Effektiv benötigen beide Klassen von Tools die selben Phasen.
Es muss auf irgend einem Weg, durch das konsekutive ausführen von Transformationen aus dem Code das Programm werden.

Diese Phasen sind klassischer Weise jene aus \autoref{fig:compiler-phases}.
Diese Phasen wurden auch im \ac{POSIX}, einem Standard für Betriebssysteme, festgehalten.~\autocite{ieee-sa-1993}

\paragraph{Lexical Analyzer,} oder auch \textbf{Tokenizer}, gruppieren den Code in \textbf{Tokens}.
Ein Token ist dabei ein Zweitupel aus seinem Typen und seinem Wert, ein optionalen Eintrag in der SymbolTable.

Die zugrundeliegende Datenstruktur bleibt dabei ein Stream.
Es handelt sich also immer noch um eine lineare Datenstruktur.

Der wohl bekannteste Tokenizer ist dabei Lex.~\autocite{wikipedia-contributors-2024G}
Lex folgt dem \ac{POSIX} Standard und ist in \autoref{subsubsec:lex} beschriebene.

\paragraph{Syntax Analyzer,} oder auch \textbf{Parser}, analysieren die Reihenfolge, in der die einzelnen Tokens evaluiert werden.
Dazu wird mittels einer \ac{CFG}~\autocite{wikipedia-contributors-2024H} ein \textbf{syntax tree}, oder auch \textbf{\ac{AST}}, erstellt.

Der \ac{AST} beinhaltet im Regelfall die Tokens, die vom Tokenizer erstellt wurden, als Leafs.
Die Semantische bedeutung des \ac{AST} ist entsprechend die konsekutive Gruppierung von Tokens und anderen Gruppen.

Es werden verschiedene Arten von Parsern eingesetzt, die sich in ihrer Herangehensweise an die Analyse der Eingabesequenz unterscheiden.
Zwei wichtige Kategorien sind Top--Down-- und Bottom--Up--Parser.
\begin{figure}[ht]
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[width=\textwidth]{../assets/img/diagrams/bottom_up_parser.mmd}
        \end{center}
        \caption{Bottom--Up--Parser}
        \label{subfig:bottom-up-parser}
    \end{subfigure}
    \begin{subfigure}[c]{0.5\textwidth}
        \begin{center}
            \includegraphics[width=\textwidth]{../assets/img/diagrams/top_down_parser.mmd}
        \end{center}
        \caption{Top--Down--Parser}
        \label{subfig:top-down-parser}
    \end{subfigure}
    \caption{Arten von Parsern}
    \label{fig:parser-types}
\end{figure}

\subparagraph{Top--Down--Parser} (Siehe \autoref{subfig:top-down-parser}) starten, indem sie die größte Struktur der Grammatik versuchen, anzuwenden.~\autocite{geeksforgeeks-2021A}
Diese wird dann recursive immer weiter zerteilt.

Dabei liest er von links nach rechts.
Dadurch kann es schwierig werden, einen sinnvollen \ac{AST} zu erzeugen, wenn es uneindeutige Abfolgen gibt.

\subparagraph{Bottom--Up--Parser} (Siehe \autoref{subfig:bottom-up-parser}) starten, mit den Terminalen der Grammatik.~\autocite{geeksforgeeks-2021A}
Diese werden dann nach und nach zu größeren Strukturen zusammengesetzt.

Dabei liest er von rechts nach links.
Dadurch kann es schwierig sein, den nächsten Token auszuwählen.

\paragraph{Semantic Analyzer} analysiert die Nodes des \ac{AST} auf semantische korrektheit.
Hier werden zum Beispiel Variable auf Scopes geprüft und das Typechecking durchgeführt.
Auch werden Konstante werte errechnet.

Kurzum ist diese Phase dafür verantwortlich, Feedback zum Code zu geben.
Dabei werden in der Regel Warnings und Errors ausgegeben.

Dies stellt sicher, dass nur korrekte Programme weiter kompiliert werden.
Ausnahmen dazu gibt es zum Beispiel mit JavaScript.
Hier wird jedes Statement versucht zu interpretieren, um einfache Fehler unter den Tisch zu kehren.

\paragraph{Intermediate Code Generator} erstellt Text aus dem \ac{AST} eine Computer--verständliche Zwischendarstellung.

Ein Beispiel aus~\cite{aho-2006} wäre der three--address code.
Dieser ist eine klassische \textbf{intermediate representation} beim Kompilieren zu Assembly.

Der Zweck dieser Zwischendarstellung ist meistens, dass sie in einer Textdatei abgelegt werden kann.
Der Vorteil davon ist, dass das Frontend der Compiler--Pipeline\footnote{Als Frontend des Compilers werden die ersten 5 Phasen bezeichnet, als Backend die letzten beiden.} klassischerweise unabhängig von der Prozessorarchitektur ist und es so potenziell mehrere, unabhängig voneinander entwickelte, Backends für die verschiedenen Prozessorarchitekturen geben kann.

Da \acp{DSL} im Gegensatz zu \acp{GPL} meist keine Abhängigkeit zu Prozessorarchitekturen haben, fällt die Wahl der intermediate representation häufig direkt auf den \ac{AST}.

\paragraph{Machine--Independent Code Optimizer} tun genau das, was der Name auch sagt: sie nehmen mögliche Optimierungen an der intermediate representation vor.

Diese Optimierungen beinhalten zum Beispiel das entfernen von unnötigem Code, Obfuscating von Identifiers, Aufräumen von Ressourcen, \dots.

Der Code kann anhand von verschiedensten Metriken optimiert werden.
Dazu zählt Geschwindigkeit, Dateigröße\footnote{Ist im Web wichtig.}, \dots.

Optimierungsphasen sind immer optional.
Im C--Compiler der \ac{GCC} kann zum Beispiel auch eingestellt werden, wie stark der Code optimiert werden soll.~\autocite{gnu-project-no-date}

\paragraph{Code Generator,} oder auch \textbf{Compiler}, erzeugen nun aus der \textbf{intermediate representation} den \textbf{target--machine code}.

Im Gegensatz zu den meisten anderen Schritten ist diese Phase nicht so standardisiert.
Dies liegt an der möglichen abhängigkeit von Prozessorarchitekturen.

Tools wie \ac{LLVM}~\autocite{llvm-project-2024} nehmen sich der Verallgemeinerung der meisten Prozessorarchitekturen an.
Damit sind sie allerdings relevanter beim Entwickeln von \ac{GPL} als \ac{DSL}.

Tools speziell für \ac{DSL} konnten wir nicht finden.
Allerdings ist diese letzte transformation, wie die Umsetzung aus \autoref{lst:compiler} zeigt, nach entsprechender Aufbereitung der Daten durch die restliche Pipeline, nicht explizit kompliziert.


\paragraph{Machine--Dependent Code Optimizer} optimieren den Code analog zu Machine--Independent Code Optimizer, nur spezifisch für die Zielplattform.

\subsubsection{Lex}\label{subsubsec:lex}
Lex ist die Abkürzung für Lexical Analyzer und das bekannteste Tool zur erstellung von Tokenizern.

Die Tokens werden dabei durch \acp{RegEx} identifiziert und von links nach rechts eingelesen.
Standardmäßig sucht Lex nach dem längsten Treffer, es kann allerdings auch über eine Flag des \ac{CLI} nach dem kürzesten Match gesucht werden.

Lex Programme sind dabei in drei Abschnitte unterteilt:
\lstinputlisting[label={lst:lex-structure},caption={Aufbau eines Lex Programms},language=lex]{../assets/code/c/lex_structure.l}

\paragraph{Definitions} beinhalten vor allem die Namen der Tokens.
Aber auch gegebenenfalls Optionen zur konfiguration des Lex Compilers oder auch C Code, meistens Imports.

Wird Lex zusammen mit \ac{YACC} verwendet, so werden die Namen der Tokens in YACC definiert.
In dem Fall wird hier nur der \ac{YACC} Header importiert und der Abschnitt bleibt ansonsten weitestgehend leer.

\paragraph{Rules} spezifizieren die \ac{RegEx} Ausdrücke und die zugehörigen Tokens, also die Namen aus der ersten Sektion und gegebenenfalls anfallende Einträge in der Symbol Table.
\lipsum[5]

\paragraph{Auxiliary Functions} sind einfach beliebige C funktionen.
Diese werden allerdings nicht über einen Header exposed, sondern sind nur zur Verwendung innerhalb des Lex Programms gedacht.

Soll ein Lex Programm ein eigenes \ac{CLI} definieren, so wird hier üblicherweise die \verb|main()| Methode definiert.
Anderenfalls bleibt dieser Abschnitt zumeist leer, da Funktionen ausgelagert werden.
In dem Fall werden sie im ersten Abschnitt importiert.

\paragraph*{}
Das ergebnis des Lex Compilers ist immer eine C--Datei.
Diese kann entweder von anderen C--Programmen verwendet werden, oder mittels eines herkömmlichen C--Compilers kompiliert werden.

Meistens wird Lex zusammen mit \ac{YACC} verwendet.

\subsubsection{\acs{YACC}}
\ac{YACC} ist ein Tool zum erstellen von \ac{LALR} rightmost derivation Parsern nach dem \ac{POSIX} Standard.
\acs{LALR}--Parser sind dabei eine Untergruppe der Bottom--Up--Parser.
Sie funktionieren, indem \lipsum[5]

Ein \ac{YACC} Programm ist immer in die folgenden 3 Teile gegliedert:
\lstinputlisting[label={lst:yacc-structure},caption={Aufbau eines \acs{YACC} Programms},language=yacc]{../assets/code/c/yacc_structure.y}
\lipsum[5]

\subsubsection{Compiler}
Auch zum erstellen von Compilern gibt es Tools, allerdings ist es hier auch üblich, diese manuel zu erstellen.
In \autoref{lst:compiler} ist beispielhaft ein solcher Compiler für den in \autoref{sec:vergleich-der-tool-sets-anhand-eines-einfachen-beispiels} verwendeten Compiler der PlayerConfig--Sprache abgebildet.
\lstinputlisting[label={lst:compiler},caption={Einfacher Compiler in C},language=c]{../assets/code/c/compiler.c}
\lipsum[5]

\subsection{\acl{MPS}}\label{subsec:meta-programming-system}
\ac{MPS} macht einiges anders als \ac{POSIX}.
Der Ausgangspunkt\footnote{Eingabe des Programms} ist keine Textdatei, sondern der \ac{AST} der zu definierenden Sprache.
Dies funktioniert, da \ac{MPS} nur in der gleichnamigen \ac{IDE} verwendet werden kann.

\begin{wrapfigure}{lH}{0.5\textwidth}
    \begin{center}
        \includegraphics[width=0.48\textwidth]{../assets/img/diagrams/mps.mmd}
    \end{center}
    \caption{Grundlegende Struktur von \acs{MPS}}
    \label{fig:mps}
\end{wrapfigure}
Der \ac{AST} wird dabei durch den \textbf{Editor} in eine Representation für den Menschen gerendert und über Transformationsregeln bearbeitet.

Auch das Kompilieren läuft in der Regel anders.
Einfache Sprachen haben klassischen Code Generator, in \ac{MPS} \textbf{TextGen} genannt.
Im Regelfall werden allerdings Transpiler\footnote{Ein Compiler, der eine Sprache als Eingabe und eine andere Sprache als Ausgabe hat.} verwendet.
Diese übersetzen mittels einer Template--Sprache von einem \ac{MPS} \ac{AST} in einen anderen \ac{MPS} \ac{AST}.
So wird durch die Konkatenation

\lipsum[5]

\subsubsection{Structure}
\begin{figure}
    \includegraphics[width=\textwidth]{../assets/img/diagrams/ard_player_mps_structure.mmd}
    \caption{ARD.Player MPS Sprache Struktur}
    \label{fig:ard-player-mps-structure}
\end{figure}
\lipsum[5]

\subsubsection{TextGen}
\lipsum[5]

\subsubsection{Generator}
\lipsum[5]

\subsubsection{GenPlan}
\lipsum[5]

\subsubsection{Editor}
\lipsum[5]
